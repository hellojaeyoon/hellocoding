# 20200910

오늘은 어김없이 문제를 풀며 실력을 다지는 시간이었다.



#### 이진탐색

- 1 부터 N까지의 자연수를 이진 탐색트리에 저장하는데, N이 주어졌을때 완전 이진 트리로 만든 이진 탐색 트리의 루트에 저장된값, 그리고 N//2 번 노드에 저장된 값을 출력해보자.
- 완전 이진 트리의 노드 번호는 루트를 1번으로 하고 아래로 내려가면서 왼쪽에서 오른쪽으로 증가한다.

```python
def binSearch(k):
    if k == 0:
        return
    if left[k] != 0:
        binSearch(left[k])
    result.append(k)
    if right[k] != 0:
        binSearch(right[k])

def biTree(N):
    k = 1
    counter = 1
    while counter <= N:
        counter += 1
        if counter <= N:
            left[k] = counter
            counter += 1
        else: break
        if counter <= N:
            right[k] = counter
        else:break
        k += 1

T = int(input())

for i in range(1, T+1):
    N = int(input())
    left = [0]*(N+1)
    right = [0]*(N+1)
    biTree(N)
    result = []
    binSearch(1)
    # print(left)
    # print(right)
    # print(result)
    print(f'#{i} {result.index(1)+1} {result.index(N//2)+1}')
```

-  앞에서 했던 내용이라 그런지 큰 문제는 없었다

나머지 문제들도 큰 어려움은 없었기에, 프로그래머스에 있는 기둥과, 보 라는 문제를 풀어본것을 적어보려한다.



# 기둥과 보

빙하가 깨지면서 스노우타운에 떠내려 온 **죠르디**는 인생 2막을 위해 주택 건축사업에 뛰어들기로 결심하였습니다. 죠르디는 **기둥과 보**를 이용하여 벽면 구조물을 자동으로 세우는 로봇을 개발할 계획인데, 그에 앞서 로봇의 동작을 시뮬레이션 할 수 있는 프로그램을 만들고 있습니다.
프로그램은 **2차원 가상 벽면**에 기둥과 보를 이용한 구조물을 설치할 수 있는데, 기둥과 보는 **길이가 1인 선분**으로 표현되며 다음과 같은 규칙을 가지고 있습니다.

- 기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다.
- 보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다.

단, 바닥은 벽면의 맨 아래 지면을 말합니다.

2차원 벽면은 **`n x n`** 크기 정사각 격자 형태이며, 각 격자는 **`1 x 1`** 크기입니다. 맨 처음 벽면은 비어있는 상태입니다. 기둥과 보는 격자선의 교차점에 걸치지 않고, 격자 칸의 각 변에 정확히 일치하도록 설치할 수 있습니다. 다음은 기둥과 보를 설치해 구조물을 만든 예시입니다.

![기둥과보-1.jpg](https://grepp-programmers.s3.amazonaws.com/files/production/c453630fa0/834b86e5-6fd0-4d3c-8023-7f853ea4301f.jpg)

예를 들어, 위 그림은 다음 순서에 따라 구조물을 만들었습니다.

1. (1, 0)에서 위쪽으로 기둥을 하나 설치 후, (1, 1)에서 오른쪽으로 보를 하나 만듭니다.
2. (2, 1)에서 위쪽으로 기둥을 하나 설치 후, (2, 2)에서 오른쪽으로 보를 하나 만듭니다.
3. (5, 0)에서 위쪽으로 기둥을 하나 설치 후, (5, 1)에서 위쪽으로 기둥을 하나 더 설치합니다.
4. (4, 2)에서 오른쪽으로 보를 설치 후, (3, 2)에서 오른쪽으로 보를 설치합니다.

만약 (4, 2)에서 오른쪽으로 보를 먼저 설치하지 않고, (3, 2)에서 오른쪽으로 보를 설치하려 한다면 2번 규칙에 맞지 않으므로 설치가 되지 않습니다. 기둥과 보를 삭제하는 기능도 있는데 기둥과 보를 삭제한 후에 남은 기둥과 보들 또한 위 규칙을 만족해야 합니다. 만약, 작업을 수행한 결과가 조건을 만족하지 않는다면 해당 작업은 무시됩니다.

벽면의 크기 n, 기둥과 보를 설치하거나 삭제하는 작업이 순서대로 담긴 2차원 배열 build_frame이 매개변수로 주어질 때, 모든 명령어를 수행한 후 구조물의 상태를 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- n은 5 이상 100 이하인 자연수입니다.
- build_frame의 세로(행) 길이는 1 이상 1,000 이하입니다.
- build_frame의 가로(열) 길이는 4입니다.
- build_frame의 원소는 [x, y, a, b]형태입니다.
  - x, y는 기둥, 보를 설치 또는 삭제할 교차점의 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.
  - a는 설치 또는 삭제할 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.
  - b는 구조물을 설치할 지, 혹은 삭제할 지를 나타내며 0은 삭제, 1은 설치를 나타냅니다.
  - 벽면을 벗어나게 기둥, 보를 설치하는 경우는 없습니다.
  - 바닥에 보를 설치 하는 경우는 없습니다.
- 구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제합니다.
- 구조물이 겹치도록 설치하는 경우와, 없는 구조물을 삭제하는 경우는 입력으로 주어지지 않습니다.
- 최종 구조물의 상태는 아래 규칙에 맞춰 return 해주세요.
  - return 하는 배열은 가로(열) 길이가 3인 2차원 배열로, 각 구조물의 좌표를 담고있어야 합니다.
  - return 하는 배열의 원소는 [x, y, a] 형식입니다.
  - x, y는 기둥, 보의 교차점 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.
  - 기둥, 보는 교차점 좌표를 기준으로 오른쪽, 또는 위쪽 방향으로 설치되어 있음을 나타냅니다.
  - a는 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.
  - return 하는 배열은 x좌표 기준으로 오름차순 정렬하며, x좌표가 같을 경우 y좌표 기준으로 오름차순 정렬해주세요.
  - x, y좌표가 모두 같은 경우 기둥이 보보다 앞에 오면 됩니다.

### 입출력 예

| n    | build_frame                                                  | result                                                       |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 5    | [[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]] | [[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]] |
| 5    | [[0,0,0,1],[2,0,0,1],[4,0,0,1],[0,1,1,1],[1,1,1,1],[2,1,1,1],[3,1,1,1],[2,0,0,0],[1,1,1,0],[2,2,0,1]] | [[0,0,0],[0,1,1],[1,1,1],[2,1,1],[3,1,1],[4,0,0]]            |

### 입출력 예에 대한 설명

**입출력 예 #1**

문제의 예시와 같습니다.

**입출력 예 #2**

여덟 번째 작업을 수행 후 아래와 같은 구조물 만들어집니다.

![기둥과보-2.jpg](https://grepp-programmers.s3.amazonaws.com/files/production/e62b852aba/ff82828f-5d2c-43af-b734-2752a776a234.jpg)

아홉 번째 작업의 경우, (1, 1)에서 오른쪽에 있는 보를 삭제하면 (2, 1)에서 오른쪽에 있는 보는 조건을 만족하지 않으므로 무시됩니다.

열 번째 작업의 경우, (2, 2)에서 위쪽 방향으로 기둥을 세울 경우 조건을 만족하지 않으므로 무시됩니다.

---

### 입출력 예

| n    | build_frame                                                  | result                                                       |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 5    | [[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]] | [[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]] |
| 5    | [[0,0,0,1],[2,0,0,1],[4,0,0,1],[0,1,1,1],[1,1,1,1],[2,1,1,1],[3,1,1,1],[2,0,0,0],[1,1,1,0],[2,2,0,1]] | [[0,0,0],[0,1,1],[1,1,1],[2,1,1],[3,1,1],[4,0,0]]            |

```python
def solution(n, build_frame):
    answer = []
    def P_add(x, y): # 기둥을 x,y에 설치할 수 있는지에 대한 여부를 반환하는 함수
        # 우선 바닥이면 설치할 수 있다
        if y == 0: 
            return True
        # 바닥이 아니라면, 그 아래에 기둥이 있었거나, x,y기준 양옆중 하나에 보가 있으면 설치 할 수 있다.
        elif [x-1,y,1] in answer or [x,y,1] in answer or [x,y-1,0] in answer:
            return True
        else: # 그게 아니라면 설치가 불가능하다.
            return False

    def B_add(x,y): # 보를 x,y에 설치할 수 있는지에 대한 여부를 반환하는 함수
        
        # 그 보 기준 좌우 아래에 기둥이 설치되어 있는 경우 설치 할 수 있다.
        if [x,y-1,0] in answer or [x+1,y-1,0] in answer: 
            return True
        # 그 보 기준 좌우에 보가 설치되어 있다면 설치 할 수 있다.
        elif [x-1,y,1] in answer and [x+1,y,1] in answer:
            return True
        else:
            return False

    def P_del(x,y): # 기둥의 삭제 가능여부를 판단하여 반환하는 함수
        count = 0
        # 우선 그 기둥의 삭제에 영향을 받는 보 and 기둥은 총 3개이다
        # 그 3곳에 대해 각각 삭제해도 된다면 count를 늘려주고 3이면 True를 반환한다.

        # 바로위의 기둥에 대해
        # 기둥이 있었다면
        if [x,y+1,0] in answer:
            # 기둥이 그래도 서 있을 수 있다면(아래에 보가 하나라도 있다면
            if [x-1,y+1,1] in answer or [x,y+1,1] in answer:
                count += 1
        # 기둥이 없었다면, 그 기둥삭제엔 문제가 없으므로 count += 1 을 해준다
        else:
            count += 1
        
        # 좌측에 보가 있었다면
        if [x-1,y+1,1] in answer:
            if [x-1,y,0] in answer:
                count +=1
            elif [x-2,y+1,1] in answer and [x,y+1,1] in answer:
                count +=1
        else:
            count += 1
        # 우측에 보가 있었다면
        if [x,y+1,1] in answer:
            if [x+1,y,0] in answer:
                count +=1
            elif [x-1,y+1,1] in answer and [x+1,y+1,1] in answer:
                count +=1
        else:
            count += 1
        #3가지 케이스에 대해 문제가 없다면
        if count == 3:
            return True
        else:
            return False
    
    def B_del(x,y):
        count = 0
        # 보와 같은경우 삭제되었을때 영향을 주는 보 and 기둥은 총 4개이다.
        # 마찬가지로 각각에 대해 삭제를 하여도 문제가 없다는 판단을 해 count를 1씩 늘려준다
        if [x-1,y,1] in answer:
            if [x-1,y-1,0] in answer or [x,y-1,0] in answer:
                count += 1
        else:
            count += 1

        if [x+1,y,1] in answer:
            if [x+1,y-1,0] in answer or [x+2,y-1,0] in answer:
                count += 1
        else:
            count += 1

        if [x,y,0] in answer:
            if [x,y-1,0] in answer or [x-1,y,1] in answer:
                count += 1
        else:
            count += 1

        if [x+1,y,0] in answer:
            if [x+1,y-1,0] in answer or [x+1,y,1] in answer:
                count += 1
        else:
            count += 1

        if count == 4:
            return True
        else:
            return False

    # 설치를 하는 함수이다.
    # answer이라는 리스트에, 기둥과 보를 설치할때 넣어준다.
    def E(x, y, what):
        if what == 0:
            if P_add(x, y):
                answer.append([x, y, what])
                # Pan 값 조정
        elif what == 1:
            if B_add(x, y):
                answer.append([x, y, what])
                # Pan 값 조정
        else:
            pass
	# answer이라는 리스트로부터, 기둥과 보를 빼줄때 사용하는 함수
    def D(x, y, what):
        if what == 0:
            if P_del(x, y):
                answer.remove([x, y, what])
                # Pan 값 조정
        elif what == 1:
            if B_del(x, y):
                answer.remove([x, y, what])
                # Pan 값 조정
        else:
            pass
	
    # 사실상 실행하는 함수, 각각의 action에 대해 설치를 하거나 삭제를 한다.
    for action in build_frame:
        if action[3] == 1:
            E(action[0],action[1],action[2])
        elif action[3] == 0:
            D(action[0],action[1],action[2])

    answer.sort()
    return answer






#print(solution(5,[[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]]))
#print(solution(5,[[0,0,0,1],[2,0,0,1],[4,0,0,1],[0,1,1,1],[1,1,1,1],[2,1,1,1],[3,1,1,1],[2,0,0,0],[1,1,1,0],[2,2,0,1]]))
```

