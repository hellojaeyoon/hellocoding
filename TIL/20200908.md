# 20200908

오늘은 몇개의 문제들을 푸는 시간이었다.

## 1861

방이 N×N형태로 늘어서 있을때, 각 방에는 1 ~ N^2 의 숫자들이 적혀있다(모든방에 대해 서로 다르다)

이때 각 방에서 상하좌우에 있는 인접한방에 가기 위해선 인접한 방의 숫자가 현재방보다 1 커야한다.

그럼 어느 위치에서 출발해야 가장 많은 방을 지날 수 있을까?

```python
'''
2
2
1 2
3 4
3
9 3 4
6 1 5
7 8 2
'''
def neighbor(node,N):
    r,c = node[0], node[1]
    rx = [-1,0,1,0]
    cx = [0,1,0,-1]
    resultLs = []
    for i in range(4):
        if 0 <= r + rx[i] < N and 0 <= c + cx[i] < N:
            if graph[r+rx[i]][c+cx[i]] == graph[r][c] + 1:
                resultLs.append([r+rx[i],c+cx[i]])
    return resultLs

def bfs(r,c,N):
    visited = [[0]*N for _ in range(N)]
    node = [r,c]
    Q = [node]
    result = [[0]*N for _ in range(N)]
    while Q:
        node = Q.pop(0)
        if visited[node[0]][node[1]] == 0:
            visited[node[0]][node[1]] = 1
            nei = neighbor(node,N)
            Q.extend(nei)
            for point in nei:
                result[point[0]][point[1]] = result[node[0]][node[1]] + 1
    maxre = 0
    for row in range(N):
        for col in range(N):
           if maxre < result[row][col]:
               maxre = result[row][col]

    return maxre

T = int(input())

for i in range(1, T+1):
    N = int(input())
    graph = [list(map(int,input().split())) for _ in range(N)]
    result = {}
    for row in range(N):
        for col in range(N):
            result[f'{row} {col}'] = bfs(row,col,N)
    maxVal = 0
    for val in result.values():
        if val > maxVal:
            maxVal = val
    final = []
    for key in result.keys():
        if result[key] == maxVal:
            r,c = map(int,key.split())
            final.append(graph[r][c])
    ans = min(final)
    print(f'#{i} {ans} {maxVal+1}')
```

```python
#1 1 2
#2 3 3
```

- 결론부터 말하면 크기가 큰 입력값을 받았을 때`제한시간 초과` 에러가 났고, 실제로 내 컴퓨터로 돌려봤을때, 내 cpu를 다 잡아먹으면서 엄청 컴퓨터가 아예 멈춰버렸다.

- 쓸데없이 모든점을 다 검사하지말고, 이미 지나간점은 처음 `search`단계에서 부터 빼보도록 했다.

```python
def neighbor(node, N):  # 한 위치에 대한 옳은(+1인)이웃된 점들을 list로 return
    r, c = node[0], node[1]
    rx = [-1, 0, 1, 0]
    cx = [0, 1, 0, -1]
    resultLs = []
    for i in range(4):
        if 0 <= r + rx[i] < N and 0 <= c + cx[i] < N:
            if graph[r + rx[i]][c + cx[i]] == graph[r][c] + 1:
                resultLs.append([r + rx[i], c + cx[i]])
    return resultLs


# 각 점에 있는 value의 값은 그 점에서 가장 멀리갔을때 이동한 거리이다.

def bfs(r, c, N):
    Ls = neighbor([r, c], N)
    for point in Ls: # 이미 숫자가 주어진 점이 인접해 있다면, 그 점+1 의 거리를 반환
        if value[point[0]][point[1]] != -1:
            value[r][c] = value[point[0]][point[1]] + 1
            return value[r][c]
	# 이미 숫자가 주어진 점이라면 그 숫자를 반환
    if value[r][c] != -1:
        return value[r][c]
    else:
        Q = [[r, c]] # 한 번의 경로를 쭉 이었을때, 최종목적지로부터의 거리를 각각 계산하여 value에 넣어준다. 꽤 비효율적이다. 중간에 만나면 그만멈춰야되는데, 시작점에 대해서만 해버렸다.
        visited = []
        temp = [[0] * N for _ in range(N)]
        temp[r][c] = 0
        valueLs = [0]
        path = [[r, c]]
        while Q:
            node = Q.pop(0)
            path.append(node)
            if node not in visited:
                visited.append(node)
                Ls = neighbor(node, N)
                Q.extend(Ls)
                for point in Ls:
                    temp[point[0]][point[1]] = temp[node[0]][node[1]] + 1
                    valueLs.append(temp[point[0]][point[1]])
        s = max(valueLs)
        value[r][c] = s
        for point in path:
            value[point[0]][point[1]] = s - temp[point[0]][point[1]]
        # print(value)
        return value[r][c]

    # return value[r][c]


T = int(input())

for i in range(1, T + 1):
    N = int(input())
    graph = [list(map(int, input().split())) for _ in range(N)]
    value = [[-1] * N for _ in range(N)]
    result = 0
    resultpoint = []
    for row in range(N):
        for col in range(N):
            b = bfs(row, col, N)
            if result < b:
                result = b
    for row in range(N):
        for col in range(N):
            if value[row][col] != result:
                continue
            else:
                resultpoint.append(graph[row][col])

    print(f'#{i} {min(resultpoint)} {result + 1}')
```

- 이건 테스트케이스들을 다 통과했다.
- 하지만 아직도 메모리사용량도 높고 코드가 깔끔하지 못하다고 느껴진다.