# 20_09_15_BOJ2110 (이분탐색)

## 문제

도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.

도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.

C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.

## 입력

첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (1 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.

## 예제 입력 1 

```
5 3
1
2
8
4
9
```

## 예제 출력 1 

```
3
```

---

```python
# 시간초과로 실패한 코드와 그에 대한 고찰
#
# def howMany(gap):
#     start = houses[0]
#     counter = 1
#     for i in range(N):
#         if houses[i] >= start+gap:
#             start = houses[i]
#             counter += 1
#
#     return counter
#
# N, C = map(int,input().split())
# houses = [0]*N
# for i in range(N):
#     houses[i] = int(input())
# houses.sort()
# gap = (houses[-1] - houses[0])//(C-1)
#
# while howMany(gap) < C:
#     gap -= 1
#
# print(gap)
# ---------------------------------------------------------------------
# 우선 우리가 구해야하는 값은 간격에 대한 최대값인것에 착안했다.
# 간격은 1 부터 (houses[-1] - houses[0])//(C-1) 까지의 숫자가 될 수 있다.
#
# 위에 있는 코드는 가장 큰 값인 (houses[-1] - houses[0])//(C-1) 부터
# 하나씩 간격을 줄여서 카운팅을 한 것이었는데, 하나씩 줄이다가 C개의 집에 설치하게 되면
# 멈추었을때가 최대값이 된다
# 하지만 위와같은 논리로 코드를 짜면 백준 채점기준 2%에서 계속 시간초과가 떴다.
# 극단적인 케이스들을 적으며 살펴보다 보니
# 그건 예를들면 [1,2, ..., 999999, 1000000, 999990999,999991000,...,1000000000] 와 같이
# 집들이 배치되어 있는 경우 C = 1001000 이라고 했을때(즉 위에있는 예시의 N과 같다)
# gap은 9901에서 시작하고 끊임없이 gap -= 1 을 진행해서 최종답인 1까지 와야했다.
# 시간초과만 10개 가까이 띄우다가 알고리즘 분류를 눌러보니 이분탐색이라고 써져 있어서
# gap을 다시 이분탐색으로 찾는 코드로 수정했다

# 1 부터 (houses[-1] - houses[0])//(C-1) 까지의 숫자들 중
# 우리가 원하는 gap을 이분탐색으로 찾는 방식이다

# 최소간격이 gap일때 공유기를 설치한 집의 수 (즉 이 값이 C이상이면 최소한 이 gap이상의 숫자가 답이된다)
def howMany(gap):
		# 간단히 맨 처음집부터 시작해서 다음집들중 gap이상의 거리에 있는 집을 찾는다.
    start = houses[0]
    counter = 1
    for i in range(N):
				# 찾고나면 그 집을 다시 시작점으로 초기화해주고, 집에 설치를 했다는 표시
				# 즉 counter += 1을 해준다
        if houses[i] >= start+gap:
            start = houses[i]
            counter += 1
		# 최종적으로 설치한 집들의 수를 반환한다
    return counter

N, C = map(int,input().split())
# 처음에 append로 이어 붙이다가, 시간초과가 계속해서 뜨는바람에 append문제인가 하고
# 아예 집들의 위치를 저장할 list를 미리 만들어서 입력했었다(이건 사실 문제가 아니었지만
# 실제로 이렇게 하는게 속도면에서(즉 연산하는 면에서) 훨씬 괜찮다고 한다.)
houses = [0]*N
for i in range(N):
    houses[i] = int(input())
houses.sort()

# gap값을 이분탐색으로 찾기 전 시작점과 끝점을 저장해준다
s, e = 1, (houses[-1] - houses[0])//(C-1)

# 간단한 이분탐색함수
while s <= e:
    gap = (s+e)//2
    if howMany(gap) < C:
        e = gap - 1
    else:
				# 원하는 값일 가능성이 있기에 우선 저장해준다.
				# 더 큰 gap이 howMany(gap) >= C를 만족할 수도 있기때문
        ans = gap
        s = gap + 1

# 최종적으로 ans에 저장된 gap이 정답이된다.
print(ans)
```

